import javax.swing.*;
import java.awt.*;

public class ChessBoardPanel extends JPanel {
    private final int CHESS_COUNT = 8;
    private ChessGridComponent[][] chessGrids;

    public ChessBoardPanel(int width, int height) {
        this.setVisible(true);
        this.setFocusable(true);
        this.setLayout(null);
        this.setBackground(Color.BLACK);
        int length = Math.min(width, height);
        this.setSize(length, length);
        ChessGridComponent.gridSize = length / CHESS_COUNT;
        ChessGridComponent.chessSize = (int) (ChessGridComponent.gridSize * 0.8);
        System.out.printf("width = %d height = %d gridSize = %d chessSize = %d\n",
                width, height, ChessGridComponent.gridSize, ChessGridComponent.chessSize);

        initialChessGrids();//return empty chessboard
        initialGame();//add initial four chess

        repaint();
    }

    /**
     * set an empty chessboard
     */
    public void initialChessGrids() {

        chessGrids = new ChessGridComponent[CHESS_COUNT][CHESS_COUNT];
        //创建棋盘数组
        //draw all chess grids
        for (int i = 0; i < CHESS_COUNT; i++) {
            for (int j = 0; j < CHESS_COUNT; j++) {
                //创建一个小格子
                ChessGridComponent gridComponent = new ChessGridComponent(i, j);
                //设置小格子的位置
                gridComponent.setLocation(j * ChessGridComponent.gridSize, i * ChessGridComponent.gridSize);
                chessGrids[i][j] = gridComponent;//将小格子放入棋盘
                this.add(chessGrids[i][j]);
            }
        }
    }

    /**
     * initial origin four chess
     */
    public void initialGame() {
        clearChessPieces();
        chessGrids[3][3].setChessPiece(ChessPiece.BLACK);
        chessGrids[3][4].setChessPiece(ChessPiece.WHITE);
        chessGrids[4][3].setChessPiece(ChessPiece.WHITE);
        chessGrids[4][4].setChessPiece(ChessPiece.BLACK);
        repaint();
    }

    private void clearChessPieces() {
        for (int i = 0; i < CHESS_COUNT; i++) {
            for (int j = 0; j < CHESS_COUNT; j++) {
                chessGrids[i][j].setChessPiece(null);
            }
        }
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        g.setColor(Color.BLACK);
        g.fillRect(0, 0, this.getWidth(), this.getHeight());
    }

    public boolean canClickGrid(int row, int col, ChessPiece currentPlayer) {
        int b = 0, c = 0;
        if (currentPlayer == ChessPiece.BLACK) {
            b = 1;
            c = -1;
        }
        if (currentPlayer == ChessPiece.WHITE) {
            b = -1;
            c = 1;
        }
        return dir1(getgamedata(), row, col, b, c) || dir2(getgamedata(), row, col, b, c) || dir3(getgamedata(), row, col, b, c) || dir4(getgamedata(), row, col, b, c)
                || dir5(getgamedata(), row, col, b, c) || dir6(getgamedata(), row, col, b, c) || dir7(getgamedata(), row, col, b, c) || dir8(getgamedata(), row, col, b, c);

    }

    public void loadGameByData(int[][] dataS) {
        clearChessPieces();
        for (int i = 0; i < CHESS_COUNT; i++) {
            for (int j = 0; j < CHESS_COUNT; j++) {
                if (dataS[i][j] == 1) {
                    chessGrids[i][j].setChessPiece(ChessPiece.WHITE);
                } else if (dataS[i][j] == -1) {
                    chessGrids[i][j].setChessPiece(ChessPiece.BLACK);
                }
            }
        }
        repaint();//导入文件完成。7
    }

    public int[][] getgamedata() {
        int[][] a = new int[CHESS_COUNT][CHESS_COUNT];
        for (int i = 0; i < CHESS_COUNT; i++) {
            for (int j = 0; j < CHESS_COUNT; j++) {
                if (chessGrids[i][j].getChessPiece() == ChessPiece.BLACK) {
                    a[i][j] = -1;
                } else if (chessGrids[i][j].getChessPiece() == ChessPiece.WHITE) {
                    a[i][j] = 1;
                } else {
                    a[i][j] = 0;
                }
            }
        }
        return a;
    }

    public static boolean dir1(int a[][], int i, int j, int b/*对手棋子*/, int c) {
        int m = i - 1, n = j - 1;
        while (m >= 0 && n >= 0 && m <= 7 && n <= 7 && a[m][n] == b) {
            m--;
            n--;
        }
        if (m != i - 1 && m >= 0 && n >= 0 && a[m][n] == c)
            return true;
        else return false;
    }

    public static boolean dir2(int a[][], int i, int j, int b/*对手棋子*/, int c) {
        int m = i - 1, n = j;
        while (m >= 0 && n >= 0 && m <= 7 && n <= 7 && a[m][n] == b) {
            m--;
        }
        if (m != i - 1 && m >= 0 && n >= 0 && m <= 7 && n <= 7 && a[m][n] == c)
            return true;
        else return false;
    }

    public static boolean dir3(int a[][], int i, int j, int b/*对手棋子*/, int c) {
        int m = i - 1, n = j + 1;
        while (m >= 0 && n >= 0 && m <= 7 && n <= 7 && a[m][n] == b) {
            m--;
            n++;
        }
        if (m != i - 1 && m >= 0 && n >= 0 && m <= 7 && n <= 7 && a[m][n] == c)
            return true;
        else return false;
    }

    public static boolean dir4(int a[][], int i, int j, int b/*对手棋子*/, int c) {
        int m = i, n = j + 1;
        while (m >= 0 && n >= 0 && m <= 7 && n <= 7 && a[m][n] == b) {
            n++;
        }
        if (n != j + 1 && m >= 0 && n >= 0 && m <= 7 && n <= 7 && a[m][n] == c)
            return true;
        else return false;
    }

    public static boolean dir5(int a[][], int i, int j, int b/*对手棋子*/, int c) {
        int m = i + 1, n = j + 1;
        while (m >= 0 && n >= 0 && m <= 7 && n <= 7 && a[m][n] == b) {
            n++;
            m++;
        }
        if (m != i + 1 && m >= 0 && n >= 0 && m <= 7 && n <= 7 && a[m][n] == c)
            return true;
        else return false;
    }

    public static boolean dir6(int a[][], int i, int j, int b/*对手棋子*/, int c) {
        int m = i + 1, n = j;
        while (m >= 0 && n >= 0 && m <= 7 && n <= 7 && a[m][n] == b) {
            m++;
        }
        if (m != i + 1 && m >= 0 && n >= 0 && m <= 7 && n <= 7 && a[m][n] == c)
            return true;
        else return false;
    }

    public static boolean dir7(int a[][], int i, int j, int b/*对手棋子*/, int c) {
        int m = i + 1, n = j - 1;
        while (m >= 0 && n >= 0 && m <= 7 && n <= 7 && a[m][n] == b) {
            m++;
            n--;
        }
        if (m != i + 1 && m >= 0 && n >= 0 && m <= 7 && n <= 7 && a[m][n] == c)
            return true;
        else return false;
    }

    public static boolean dir8(int a[][], int i, int j, int b/*对手棋子*/, int c) {
        int m = i, n = j - 1;
        while (m >= 0 && n >= 0 && m <= 7 && n <= 7 && a[m][n] == b) {
            n--;
        }
        if (n != j - 1 && m >= 0 && n >= 0 && m <= 7 && n <= 7 && a[m][n] == c)
            return true;
        else return false;
    }
}
